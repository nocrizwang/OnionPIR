# SparsePIR Details

### Common Notation

- $k \in \mathcal{K}$: key in a key-value pair. 
- $v$: value in a key-value pair.
- $n$: number of key-value pairs.
- $D = \set{(k_1,v_1), \ldots, (k_n, v_n)}$: the raw database.
- $\mathrm{K}$: hash key / seed for a hash function. 
- $F(\mathrm{K}, k)$: hashing $k$ using the hash key $\mathrm{K}$. 
- $\operatorname{rep}(\mathrm{K}, k, v) = F(\mathrm{K}, k) \| v \in \mathbb{Z}_\alpha$: representing a key-value pair.
- $\alpha$: ???
- $\mathrm{K}_r$: hash key used for representation of key-value pairs in the database. 
- $\mathrm{K}_1$: hash key used for hashing a key to corresponding partition.
- $\mathrm{K_2}$: hash key used for generating rows of $\pmb{\mathrm{M}}$.

### Naive Scheme

- $\pmb{\mathrm{E}} \in \mathbb{F}^m$: Encoding. This will be calculated.
- $m = (1 + \varepsilon)n$.
- $\pmb{\mathrm{v}}_{k_i} \in \mathbb{Z}_2^m$: randomly generated bit string that corresponds to $k_i$. Generated using $K_2$ and $k_i$. 
- $\pmb{\mathrm{M}} \in \mathbb{Z}_2^{n \times m}$: row $i$ is $\pmb{\mathrm{v}}_{k_i}$. This matrix should have full row rank so to make $\pmb{\mathrm{E}} \in \mathbb{F}^m$ solvable. Must have $n \leq m$.
- $\pmb{\mathrm{y}} \in \mathbb{Z}_a^n$: the database. 

#### Server preprocessing: 

Setup $\pmb{\mathrm{M}} \cdot \pmb{\mathrm{E}} = \pmb{\mathrm{y}}$ and solve for $\pmb{\mathrm{E}}$. 

#### Query: 

Client generate $\pmb{v}_k$ and send to server. Server compute $\pmb{v}_k \cdot \pmb{\mathrm{E}}$ and return. This is using FHE multiplication.

### Partition-based Keyword PIR

Assume that the underlying PIR scheme uses recursion and represents the database as $d_1 \times \ldots \times d_z$ hypercube.

- $b = (1 + \varepsilon)n / d_1$: the number of partitions. $\varepsilon$ selected by experiment. Example: $b \approx 10000$.
- $d_1$: number of key-value pairs one partition can hold. Example: $d_1 \in \set{128, 512, 1024}$.
- $n/b = d_1 / (1 + \varepsilon) < d_1$: the expected number of pairs in each partition. Example: $\approx 100$ when $d_1 = 128$. QUESTION: is there a balls and bins problem? That max load $ > n / b$. SOLUTION: resample $\mathrm{K}_1$.
- $P_i$: the $i$-th partition consists of approximately $n / b$ many key-value paris. 
  - Note that $|P_i| \leq d_1$ so that the matrix $\pmb{\mathrm{M}}_i$ below has a full row rank. This means that each partition can hold at most $d_1$ key-value pairs.
- $i \in [b]$.
- $\pmb{\mathrm{M}}_i \in \mathbb{Z}_2^{|Pi| \times d_1}$: generated using partition $P_i$. 
- $\pmb{\mathrm{e}}_i \in \mathbb{F}^{d_1}$: the encoding corresponds to partition $P_i$.
- $\pmb{\mathrm{y}}_i \in \mathbb{Z}_a^{|P_i|}$: the key-value pairs in the partition $P_i$.
- $\pmb{\mathrm{v}}_1 \in \mathbb{Z}_2^{d_1}$: the query vector generated by $\mathrm{K_2}$ and $k$. 

#### Server preprocessing: 

Due to partition, we can now solve for $\pmb{\mathrm{M}}_i \cdot \pmb{\mathrm{e}}_i = \pmb{\mathrm{y}}_i$ easily. The time required is about $O(d_1^3)$ for each partition. Since there are $b = (1 + \varepsilon)n / d_1$ partitions, solving all $\pmb{\mathrm{e}}_i$ is about $O( (1+\varepsilon)n d_1^2 ) = O(nd_1^2)$. Notice that this is furtur reduced by using an optimized encoding (random band matrix). So the reduced runtime is about $O(d_1)$ for each partition, resulting an approximate $O(n)$ complexity for solving all partitions.

#### Query: 

The query vector has size $d_1$. It is sent to server, and the server does $\pmb{\mathrm{v}}_1 \cdot \pmb{\mathrm{e}}_i$ for all $i \in [b]$. This is $O(b)$ many LWE vector dot product. 

Then the client perform a PIR to query the $i$ result $\pmb{\mathrm{v}}_1 \cdot \pmb{\mathrm{e}}_i$. This part, they use recursion to reduce the PIR computation.



### Need Some Experiment on Sparse

If we have the code, we can try to break the online computation to two parts: 

(1) Computation time required for all $\pmb{\mathrm{v}}_1 \cdot \pmb{\mathrm{e}}_i$. This time is inevitable as this is the core of this method. 
(2) The computation time required for getting the $i$-th result. At this point, the "database" has become $b$ entries. 

My guess is that (1) takes more than 50% time.




### The Notion of Dot Product

<center>
  <figure>
    <img src=" https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240703085445728.png " style="width:70%;" />
    <figcaption>  </figcaption>
  </figure>
</center>

<center>
  <figure>
    <img src=" https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240703085541400.png " style="width:70%;" />
    <figcaption>  </figcaption>
  </figure>
</center>


Hence, the first dimension is handeled in the same way as other dimensions. The only difference is the Hamming weight.

