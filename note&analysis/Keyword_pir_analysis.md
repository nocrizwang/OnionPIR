### A list of important variables in ChalametPIR

- $\mathrm{KV}$: key-value map. 
- $\mathcal{M} \subseteq \mathcal{K} \times \mathcal{X}$: is the raw key-value map.
- $\mathrm{k}\in \mathcal{K} = \{0, 1\}^*$: key in the key-value map.
- $\mathrm{x = KV[k]} \in \mathcal{X} = \{0, 1\}^l$: value in the key-value map.
- KWPIR: Keyword PIR. 
- $m \in \mathbb{N}$: size of the Key-value map. Equivalently, the number of entries in the database.
- $\mathrm{H}=\left\{\mathrm{h}_i\right\}_{i \in[k]}$ : a set of hash functions used in key-value filter, where $h_i: \mathcal{K} \mapsto [N]$. It maps from the key to a position in a filter.
- $\operatorname{hash} \equiv H: \mathcal{K} \mapsto \{0, 1\}^\mu$ is a random oracle function. 
- $\mu \geq 2 \epsilon$: This is set so that false-positive probability is under control. Check Lemma 4.1.
- $k$: the number of hash functions in $\mathrm{H}$.
- $\mathrm{F}$: Key-value filter with configurable false-positive probability.
- $\pmb{F} \in \mathbb{Z}_p^{N \times d}$: key-value filter in matrix representation.

- $\mathrm{fpt}_\epsilon \in \mathcal{K} \times \mathcal{X} \mapsto \{0, 1\}^{\mu + l}$: fingerprint function used in key-value filter. 
- $\epsilon$: used for configuring the false-positive probability of the Key-value filter. 
- $d$:  "To avoid, storing huge data elements in each entry of the filter, we break the filter into $d$ “columns”, each holding $\log(p)$ bits of a given row of data, and indexed by the same set of hash functions." Also specified in the other section.
- $p$: described below. Also notice that $p = 2^{\mu + l}$. Therefore, the resulf of $\mathrm{fpt}_\epsilon$ is a number in $\mathbb{Z}_p$ . 
- $N = \mathrm{ç}m$: the number of rows in $\pmb{F}$.
- ç: the blow-up introduced by the fingerprint-based filter. (Binary Fuse Filter has 1.08 $\leq$ ç $\leq$ 1.13). 
- $\mathrm{pp_{DB}}$: public parameters of this database DB.
- $(\mathrm{q, st})$: query and state. It can be generated by $\mathrm{PIR.query(pp_{DB}, k)}$​.
- 



### LWEPIR related

In this scope, $m$ is the number of entries in the database. Later we will see that $\pmb{D} \in \mathbb{Z}_p^{N \times d}$ as we store the filter inside the server as the database, which has $N$ many entries instead of $m$ key-value pairs.

- $\mathrm{DB}$: the raw database. It has $m$ elements, each made up of $w$ bits.
- $\beta \in \{0, 1\}^\lambda$: random seed for generateing $\pmb{A}$. Experimental: $\lambda = 128$
- $\pmb{A} \in \mathbb{Z}_q^{n \times m}$: pseudorandomly generated matrix. Here, $n$ is configurable. It desides the dimension of the $\pmb{M}$ below. Here, we are using FrodoPIR dimension. 
- $\pmb{D} \in \mathbb{Z}_p^{m \times d}$: encodes database in a matrix form.
- $d = \frac{w}{\log(p)}$. We "slice" the original DB into columns of size $\log(p)$ so that each cell in $\pmb{D}$ is smaller (in $\mathbb{Z}_p$). 



<center>
  <figure>
    <img src=" https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240616152519435.png " style="width:50%;" />
  </figure>
</center>

<center>
  <figure>
    <img src=" https://raw.githubusercontent.com/helloboyxxx/images-for-notes/master/uPic/image-20240616154427151.png " style="width:50%;" />
  </figure>
</center>
### My Understanding of ChalametPIR

Suppose we have a key-value map $\mathcal{M} \subseteq \mathcal{K} \times \mathcal{X}$, which is also called $\mathrm{KV}$. 

**Server Setup:** 

- Runs $\mathrm{KWPIR.setup(1^\lambda, KV)}$ to write $\mathcal{M}$ to the filter $\mathrm{F}$, which is stored as a matrix $\pmb{F} \in \mathbb{Z}_p^{N \times d}$ in the FrodoPIR scheme. In this step, server also generate public parameter $\mathrm{pp_{DB}}$.

**Client Offline:**

- Client download $\mathrm{pp_{DB}}$ (hence stateful).

**Client Online:**

1. Given a key $\mathrm{k}$, the client runs $k$ many hash functions: $\mathrm{H(k)} = [h_1(\mathrm{k}), \ldots, h_k(\mathrm{k})]$. 
2. Generate a plaintext vector $\pmb{f}_{\mathrm{H(k)}} = (f_1, \ldots, f_N)$, where $f_i$ is 1 if $i \in \mathrm{H(k)}$, 0 otherwise.
3. Generate LWEPIR query and state $(\mathrm{q, st})$ using $\mathrm{LWEPIR.query(pp_{LWE}}, \pmb{f}_{\mathrm{H(k)}})$.
4. Use this $\mathrm{q}$ to get response $\mathrm{r}$ in LWEPIR. 
5. Decode $\mathrm{r}$ using $\mathrm{st}$ so to get the wanted value $\mathrm{x}$.



### Analysis & Comparison

#### About the role of KV filter in ChalametPIR

We see that the map is transformed into a BFF and stored in the server. The client only needs to hash each keyword using $\mathrm{H(k)}$ to get a few indices, which are later used to query the LWEPIR. In the ChalametPIR scheme, which uses BinaryFuse filter, the number of hash function is $k \in \{3, 4\}$. 

In this scheme, Key-value filter is not tightly bound to LWEPIR schemes. But do note that Chalamet PIR modified the LWEPIR.query() function so that the input is not a single index, but a vector $\pmb{f}$ that contains 3 or 4 ones. The resulting $\mathrm{q}$ is still a single vector. They send this query vector to the server to perform the matrix-vector multiplication, which returns a encoded version of the $\mathrm{hash(k) || x}$​​. (If need to dive into this, check the source code of ChalametPIR. Specifically, `generate_query` in their `api.rs`. )

Thought: we can indeed use this in OnionPIR. 

#### Naive variants of ChalametPIR

If we do not use matrix-vector multiplication, a naive way to solve this is to run any kind of PIR scheme $k$ many times. Each time, we get one row from the server. Let the client locally perform the addition to recover $\mathrm{hash(k) || x}$. 

#### Using Cuckoo Hashing

Naive thought: say the database uses cuckoo hashing to store the key-value pairs. The client can then use a similar method to generate a few indices to query. The only problem is that the space utilization is bad. For $m$ enties, we need to take $2m$ space for the cuckoo hashing table.

#### CGN98

As mentioned in ChalametPIR paper, this work showed a way of transforming any PIR scheme to a KWPIR scheme using $\log N$ queries. ==What is $N$?==

#### Constant-weight Codewords

Client sends a HE keyword. The server computes each bit of the vector using an equality operator — represented as an indicator function that is set to 1 when it returns true, and 0 otherwise. Then, perform an inner product. This has very high computation. 



#### Why don't we store key-value pairs directly?

Coz we can't make it secure... right? Can we make a normal `std::unordered_map<std::string, int>` secure? 





---

TODO: 

https://eprint.iacr.org/2019/1483

Learn: 

- modulus switching
- Hamming weight

https://www.usenix.org/conference/usenixsecurity23/presentation/patel



Can we combine SparsePIR and Binary Fuse Filter? 

Is SparsePIR better than using cuckoo hashing? 

SparsePIR do have some drawbacks.



Spend a little time verifying if this BFF.setupFilter



New Stateful PIR

Evaluate how to do keyword support.



---

Variable length



